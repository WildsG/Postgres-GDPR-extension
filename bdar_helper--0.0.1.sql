-- COMPLAIN IF SCRIPT IS SOURCED IN PSQL, RATHER THAN VIA CREATE EXTENSION
\ECHO USE "CREATE EXTENSION BDAR_HELPER" TO LOAD THIS FILE. \QUIT

CREATE SCHEMA IF NOT EXISTS BDAR_TABLES;
 
CREATE TABLE IF NOT EXISTS BDAR_TABLES.PRIVATE_ENTITIES(
	ID SERIAL PRIMARY KEY,
	SCHEMA_NAME VARCHAR NOT NULL,
	TABLE_NAME VARCHAR NOT NULL,
	UNIQUE(SCHEMA_NAME, TABLE_NAME)
);

CREATE TABLE IF NOT EXISTS BDAR_TABLES.DELAYED_DELETE_ROWS(
	ID SERIAL PRIMARY KEY,
	SCHEMA_NAME VARCHAR NOT NULL,
	TABLE_NAME VARCHAR NOT NULL,
	RECORD_ID INTEGER NOT NULL,
	DELETE_ON TIMESTAMP NOT NULL
);

CREATE TABLE IF NOT EXISTS BDAR_TABLES.CONF(
	ID SERIAL PRIMARY KEY,
	PARAM VARCHAR NOT NULL,
	VALUE VARCHAR NOT NULL
);

CREATE TABLE IF NOT EXISTS BDAR_TABLES.CRON_LOG(
	ID SERIAL PRIMARY KEY,
	QUERY VARCHAR NOT NULL,
	EXECUTED TIMESTAMP NOT NULL
);

CREATE TABLE IF NOT EXISTS BDAR_TABLES.POSTGRES_LOG
(
  LOG_TIME TIMESTAMP(3) WITH TIME ZONE,
  USER_NAME TEXT,
  DATABASE_NAME TEXT,
  PROCESS_ID INTEGER,
  CONNECTION_FROM TEXT,
  SESSION_ID TEXT,
  SESSION_LINE_NUM BIGINT,
  COMMAND_TAG TEXT,
  SESSION_START_TIME TIMESTAMP WITH TIME ZONE,
  VIRTUAL_TRANSACTION_ID TEXT,
  TRANSACTION_ID BIGINT,
  ERROR_SEVERITY TEXT,
  SQL_STATE_CODE TEXT,
  MESSAGE TEXT,
  DETAIL TEXT,
  HINT TEXT,
  INTERNAL_QUERY TEXT,
  INTERNAL_QUERY_POS INTEGER,
  CONTEXT TEXT,
  QUERY TEXT,
  QUERY_POS INTEGER,
  LOCATION TEXT,
  APPLICATION_NAME TEXT,
  PRIMARY KEY (SESSION_ID, SESSION_LINE_NUM)
);

CREATE TABLE IF NOT EXISTS BDAR_TABLES.ANON_CONFIG(
	COMMAND VARCHAR NOT NULL,
	VALUE VARCHAR[],
	ANON_LEVEL VARCHAR NOT NULL,
	PRIMARY KEY(ANON_LEVEL, COMMAND)
);


INSERT INTO BDAR_TABLES.CONF(PARAM, VALUE) VALUES('LOCAL', 'TRUE');
INSERT INTO BDAR_TABLES.CONF(PARAM, VALUE) VALUES('DELETE_WAIT_TIME_MINUTES', '1');

CREATE OR REPLACE FUNCTION ENCRYPT_COLUMN() 
  RETURNS TRIGGER AS
$$
DECLARE
   V_SQL TEXT;
   V_SQL1 TEXT;
  _COL TEXT := QUOTE_IDENT(TG_ARGV[0]);
BEGIN
   EXECUTE 'SELECT PGP_SYM_ENCRYPT('||'$1'||'.'||TG_ARGV[0]||','||QUOTE_LITERAL(TG_ARGV[1])||')' USING NEW INTO V_SQL;
   NEW:= NEW #= HSTORE(_COL, V_SQL);  
   RETURN NEW;
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION SET_CRYPTED_COLUMN(SCHEMA_NAME VARCHAR, TABLE_NAME VARCHAR, COLUMN_NAME VARCHAR, CRYPT_KEY VARCHAR) RETURNS VOID AS
$$
BEGIN
	EXECUTE 'CREATE TRIGGER '||SCHEMA_NAME||'_'||TABLE_NAME||'_'||COLUMN_NAME||'_CRYPT'||' BEFORE INSERT ON '||SCHEMA_NAME||'.'||TABLE_NAME||' FOR EACH ROW EXECUTE PROCEDURE ENCRYPT_COLUMN('||QUOTE_LITERAL(COLUMN_NAME)||','||QUOTE_LITERAL(CRYPT_KEY)||');';
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION REMOVE_CRYPTED_COLUMN(SCHEMA_NAME VARCHAR, TABLE_NAME VARCHAR, COLUMN_NAME VARCHAR) RETURNS VOID AS
$$
BEGIN
	EXECUTE 'DROP TRIGGER '||SCHEMA_NAME||'_'||TABLE_NAME||'_'||COLUMN_NAME||'_CRYPT'||' ON '||SCHEMA_NAME||'.'||TABLE_NAME||';';
END;
$$
LANGUAGE PLPGSQL;


INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('EMAIL',ARRAY['3', '***', '5'], 'LOW');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('PHONE',ARRAY['1','XXXX','3'], 'LOW');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('BIRTH',ARRAY['MONTH'], 'LOW');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('ZIP', ARRAY['50'], 'LOW');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('MASK',ARRAY['5', '***', '5'], 'LOW');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('NUMERIC',ARRAY['50'], 'LOW');



INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('EMAIL',ARRAY['2', '*****', '4'], 'MED');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('PHONE',ARRAY['1','XXXXXX','1'], 'MED');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('BIRTH',ARRAY['YEAR'], 'MED');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('ZIP', ARRAY['100'], 'MED');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('MASK',ARRAY['3', '***', '3'], 'MED');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('NUMERIC',ARRAY['100'], 'MED');



INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('EMAIL',ARRAY['1', '******', '2'], 'HIGH');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('PHONE',ARRAY['2','XXXXXX','0'], 'HIGH');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('BIRTH',ARRAY['DECADE'], 'HIGH');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('ZIP', ARRAY['1000'], 'HIGH');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('MASK',ARRAY['0', '***', '0'], 'HIGH');
INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES ('NUMERIC',ARRAY['1000'], 'HIGH');


CREATE OR REPLACE FUNCTION BDAR_ANONIMYZE(ANON_LVL VARCHAR, VIEW_NAME VARCHAR, COMMANDS VARCHAR[]) RETURNS VOID AS 
$$
DECLARE
	V_SQL TEXT;
	COUNTER INTEGER;
	DELETE_SQL TEXT;
	RD RECORD;
	RECORD_COUNT INTEGER;
	COLUMN_COMMAND TEXT;
	STRINGIFIED TEXT;
	ARR TEXT[];
BEGIN
	COUNTER:= 1;
	RECORD_COUNT:= (SELECT
		COUNT(C.COLUMN_NAME)
	FROM
		INFORMATION_SCHEMA.TABLES T
	LEFT JOIN INFORMATION_SCHEMA.COLUMNS C ON
		T.TABLE_SCHEMA = C.TABLE_SCHEMA
		AND T.TABLE_NAME = C.TABLE_NAME
	WHERE
		TABLE_TYPE = 'VIEW'
		AND T.TABLE_SCHEMA NOT IN ('INFORMATION_SCHEMA','PG_CATALOG','ANON')
		AND T.TABLE_NAME = VIEW_NAME);
	-- TODO LENGTH CHECK
	------------------------------------------------------------------------
	V_SQL:= 'CREATE OR REPLACE VIEW '||VIEW_NAME||'_ANONIMYZED AS
	SELECT ';
    FOR RD IN (SELECT
		C.COLUMN_NAME
	FROM
		INFORMATION_SCHEMA.TABLES T
	LEFT JOIN INFORMATION_SCHEMA.COLUMNS C ON
		T.TABLE_SCHEMA = C.TABLE_SCHEMA
		AND T.TABLE_NAME = C.TABLE_NAME
	WHERE
		TABLE_TYPE = 'VIEW'
		AND T.TABLE_SCHEMA NOT IN ('INFORMATION_SCHEMA','PG_CATALOG','ANON')
		AND T.TABLE_NAME = VIEW_NAME
	) 
    LOOP	
    	COLUMN_COMMAND:= REGEXP_REPLACE(RD::VARCHAR,'\(|\)', '', 'G');
		IF COMMANDS[COUNTER] = 'ZIP' THEN
			SELECT ARRAY_TO_STRING((SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'ZIP' AND AC.ANON_LEVEL = ANON_LVL), ',', '*') INTO STRINGIFIED;
   			COLUMN_COMMAND:= 'ANON.GENERALIZE_INT4RANGE('||COLUMN_COMMAND||'::INTEGER,'||STRINGIFIED||') AS '||COLUMN_COMMAND;
		END IF;
		IF COMMANDS[COUNTER] = 'EMAIL' THEN
			SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'EMAIL' AND AC.ANON_LEVEL = ANON_LVL INTO ARR;
   			COLUMN_COMMAND:= 'ANON.PARTIAL('||COLUMN_COMMAND||','||ARR[1]||','||QUOTE_LITERAL(ARR[2])||','||ARR[3]||') AS '||COLUMN_COMMAND;
		END IF;
		IF COMMANDS[COUNTER] = 'PHONE' THEN
			SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'PHONE' AND AC.ANON_LEVEL = ANON_LVL INTO ARR;
   			COLUMN_COMMAND:= 'ANON.PARTIAL('||COLUMN_COMMAND||','||ARR[1]||','||QUOTE_LITERAL(ARR[2])||','||ARR[3]||') AS '||COLUMN_COMMAND;
		END IF;
		IF COMMANDS[COUNTER] = 'BIRTH' THEN
			SELECT ARRAY_TO_STRING((SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'ZIP'  AND AC.ANON_LEVEL = ANON_LVL), ',', '*') INTO STRINGIFIED;
   			COLUMN_COMMAND:= 'ANON.GENERALIZE_INT4RANGE('||COLUMN_COMMAND||'::INTEGER,'||STRINGIFIED||') AS '||COLUMN_COMMAND;
		END IF;
    	V_SQL:= V_SQL||COLUMN_COMMAND||',';
    	COUNTER:= COUNTER + 1;
    END LOOP;
    V_SQL:= LEFT(V_SQL,LENGTH(V_SQL)-1)||' FROM '||VIEW_NAME||';';
   	DELETE_SQL:= 'DROP VIEW IF EXISTS '||VIEW_NAME||'_ANONIMYZED;';
   	EXECUTE DELETE_SQL;
    EXECUTE V_SQL;
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION BDAR_ANONIMYZE_COLUMN(ANON_LVL VARCHAR, VIEW_NAME VARCHAR, COLUMN_NAME VARCHAR, V_COMMAND VARCHAR) RETURNS VOID AS 
$$
DECLARE
	V_SQL TEXT;
	DELETE_SQL TEXT;
	RD RECORD;
	COLUMN_COMMAND TEXT;
	STRINGIFIED TEXT;
	ARR TEXT[];
BEGIN
	------------------------------------------------------------------------
	--SELECT ANON.LOAD();
	V_SQL:= 'CREATE OR REPLACE VIEW '||VIEW_NAME||'_ANONIMYZED AS
	SELECT ';
    FOR RD IN (SELECT
		C.COLUMN_NAME
	FROM
		INFORMATION_SCHEMA.TABLES T
	LEFT JOIN INFORMATION_SCHEMA.COLUMNS C ON
		T.TABLE_SCHEMA = C.TABLE_SCHEMA
		AND T.TABLE_NAME = C.TABLE_NAME
	WHERE
		TABLE_TYPE = 'VIEW'
		AND T.TABLE_SCHEMA NOT IN ('INFORMATION_SCHEMA','PG_CATALOG','ANON')
		AND T.TABLE_NAME = VIEW_NAME
	) 
    LOOP	
    	COLUMN_COMMAND:= REGEXP_REPLACE(RD::VARCHAR,'\(|\)', '', 'G');
    	IF COLUMN_COMMAND = COLUMN_NAME THEN
		IF V_COMMAND = 'ZIP' THEN
			SELECT ARRAY_TO_STRING((SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'ZIP' AND AC.ANON_LEVEL = ANON_LVL), ',', '*') INTO STRINGIFIED;
   			COLUMN_COMMAND:= 'ANON.GENERALIZE_INT4RANGE('||COLUMN_COMMAND||'::INTEGER,'||STRINGIFIED||') AS '||COLUMN_COMMAND;
		END IF;
		IF V_COMMAND = 'EMAIL' THEN
			SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'EMAIL' AND AC.ANON_LEVEL = ANON_LVL INTO ARR;
   			COLUMN_COMMAND:= 'ANON.PARTIAL('||COLUMN_COMMAND||','||ARR[1]||','||QUOTE_LITERAL(ARR[2])||','||ARR[3]||') AS '||COLUMN_COMMAND;
		END IF;
		IF V_COMMAND = 'PHONE' THEN
			SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'PHONE' AND AC.ANON_LEVEL = ANON_LVL INTO ARR;
   			COLUMN_COMMAND:= 'ANON.PARTIAL('||COLUMN_COMMAND||','||ARR[1]||','||QUOTE_LITERAL(ARR[2])||','||ARR[3]||') AS '||COLUMN_COMMAND;
		END IF;
		IF V_COMMAND = 'BIRTH' THEN
			SELECT ARRAY_TO_STRING((SELECT VALUE FROM BDAR_TABLES.ANON_CONFIG AC WHERE COMMAND = 'ZIP'  AND AC.ANON_LEVEL = ANON_LVL), ',', '*') INTO STRINGIFIED;
   			COLUMN_COMMAND:= 'ANON.GENERALIZE_INT4RANGE('||COLUMN_COMMAND||'::INTEGER,'||STRINGIFIED||') AS '||COLUMN_COMMAND;
		END IF;
		END IF;
    	V_SQL:= V_SQL||COLUMN_COMMAND||',';
    END LOOP;
    V_SQL:= LEFT(V_SQL,LENGTH(V_SQL)-1)||' FROM '||VIEW_NAME||';';
   	DELETE_SQL:= 'DROP VIEW IF EXISTS '||VIEW_NAME||'_ANONIMYZED;';
   	EXECUTE DELETE_SQL;
    EXECUTE V_SQL;
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ADD_ANON_RULE(V_COMMAND VARCHAR,VALUE VARCHAR[],  ANON_LVL VARCHAR) 
RETURNS TEXT AS $$
DECLARE
    V_ID TEXT;
BEGIN
	INSERT INTO BDAR_TABLES.ANON_CONFIG(COMMAND, VALUE, ANON_LEVEL) VALUES (V_COMMAND,VALUE, ANON_LVL)
	RETURNING V_COMMAND INTO V_ID;
RETURN V_ID;
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION REMOVE_ANON_RULE(V_COMMAND VARCHAR,  ANON_LVL VARCHAR) 
RETURNS TEXT AS $$
DECLARE
    V_ID TEXT;
BEGIN
	DELETE FROM BDAR_TABLES.ANON_CONFIG WHERE V_COMMAND = COMMAND AND ANON_LEVEL = ANON_LVL
	RETURNING V_COMMAND INTO V_ID;
RETURN V_ID;
END;
$$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION BDAR_SHOW_ACTIVITY_LOG() RETURNS TABLE (
  LOG_TIME TIMESTAMP(3) WITH TIME ZONE,
  USER_NAME TEXT,
  DATABASE_NAME TEXT,
  PROCESS_ID INTEGER,
  CONNECTION_FROM TEXT,
  SESSION_ID TEXT,
  SESSION_LINE_NUM BIGINT,
  COMMAND_TAG TEXT,
  SESSION_START_TIME TIMESTAMP WITH TIME ZONE,
  VIRTUAL_TRANSACTION_ID TEXT,
  TRANSACTION_ID BIGINT,
  ERROR_SEVERITY TEXT,
  SQL_STATE_CODE TEXT,
  MESSAGE TEXT,
  DETAIL TEXT,
  HINT TEXT,
  INTERNAL_QUERY TEXT,
  INTERNAL_QUERY_POS INTEGER,
  CONTEXT TEXT,
  QUERY TEXT,
  QUERY_POS INTEGER,
  LOCATION TEXT,
  APPLICATION_NAME TEXT
)
AS $$
DECLARE
    V_SELECT_Q VARCHAR;
   	DIR VARCHAR;
BEGIN 
	CREATE TEMP TABLE TMP_TABLE 
	ON COMMIT DROP AS
	SELECT * FROM BDAR_TABLES.POSTGRES_LOG WITH NO DATA;
	SELECT  SETTING FROM PG_CATALOG.PG_SETTINGS WHERE NAME = 'DATA_DIRECTORY' INTO DIR;
	V_SELECT_Q := 'COPY TMP_TABLE FROM PROGRAM '||' ''CAT '||DIR||'/LOG/*.CSV'' WITH CSV';
	EXECUTE V_SELECT_Q ;
	INSERT INTO BDAR_TABLES.POSTGRES_LOG 
	SELECT * FROM TMP_TABLE T WHERE NOT EXISTS (SELECT * FROM BDAR_TABLES.POSTGRES_LOG P WHERE P.SESSION_ID = T.SESSION_ID AND P.SESSION_LINE_NUM = T.SESSION_LINE_NUM);
	RETURN QUERY SELECT * FROM BDAR_TABLES.POSTGRES_LOG PL;
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ADD_PRIVATE_ENTITY(P_SCHEMA VARCHAR, P_TABLE VARCHAR) 
RETURNS INTEGER AS $$
DECLARE
    V_ID INTEGER;
BEGIN
	INSERT INTO BDAR_TABLES.PRIVATE_ENTITIES (SCHEMA_NAME, TABLE_NAME) VALUES (P_SCHEMA, P_TABLE)
	RETURNING ID INTO V_ID;
RETURN V_ID;
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION REMOVE_PRIVATE_ENTITY(P_SCHEMA VARCHAR, P_TABLE VARCHAR) 
RETURNS INTEGER AS $$
DECLARE
    V_ID INTEGER;
BEGIN
	DELETE FROM BDAR_TABLES.PRIVATE_ENTITIES WHERE SCHEMA_NAME = P_SCHEMA AND TABLE_NAME = P_TABLE 
	RETURNING ID INTO V_ID;
RETURN V_ID;
END;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION UPDATE_PARAMETER(PARAMETER_NAME VARCHAR, PARAMETER_VALUE VARCHAR) 
RETURNS VARCHAR AS $$
DECLARE
    V_ID VARCHAR;
BEGIN
	UPDATE BDAR_TABLES.CONF SET VALUE = PARAMETER_VALUE WHERE PARAM = PARAMETER_NAME
	RETURNING PARAMETER_VALUE INTO V_ID;
	IF(V_ID IS NULL) THEN
		RAISE EXCEPTION 'NO SUCH PARAMETER WITH % NAME', PARAMETER_NAME;
	END IF;
RETURN V_ID;
END;
$$
LANGUAGE PLPGSQL;

-- THIS FUCNTIONS IS FOR CRON USE, not used currently
CREATE OR REPLACE FUNCTION BDAR_DELETE() RETURNS INTEGER AS $$
DECLARE
    REC RECORD;
    V_SELECT_Q VARCHAR;
BEGIN
INSERT INTO BDAR_TABLES.CRON_LOG(QUERY, EXECUTED) VALUES ('HEARTBEAT', CURRENT_TIMESTAMP);
FOR REC IN
    (SELECT * FROM BDAR_TABLES.DELAYED_DELETE_ROWS  WHERE DELETE_ON < NOW() ORDER BY ID ASC)
LOOP
	V_SELECT_Q := 'DELETE FROM '||REC.SCHEMA_NAME||'.'||REC.TABLE_NAME||' WHERE ID='||QUOTE_LITERAL(REC.RECORD_ID);
    EXECUTE V_SELECT_Q;
    DELETE FROM BDAR_TABLES.DELAYED_DELETE_ROWS DDR WHERE REC.ID = DDR.ID;
    INSERT INTO BDAR_TABLES.CRON_LOG(QUERY, EXECUTED) VALUES (V_SELECT_Q, CURRENT_TIMESTAMP);
END LOOP;
RETURN 0;
END; $$
LANGUAGE PLPGSQL;


-- DEPENDENCIES
SELECT CRON.SCHEDULE('* * * * *', $JOB$
DO $$ DECLARE
    REC RECORD;
    V_SELECT_Q VARCHAR;
BEGIN
INSERT INTO BDAR_TABLES.CRON_LOG(QUERY, EXECUTED) VALUES ('HEARTBEAT1', CURRENT_TIMESTAMP);
FOR REC IN
    (SELECT * FROM BDAR_TABLES.DELAYED_DELETE_ROWS  WHERE DELETE_ON < NOW() ORDER BY ID ASC)
LOOP
	V_SELECT_Q := 'DELETE FROM '||REC.SCHEMA_NAME||'.'||REC.TABLE_NAME||' WHERE ID='||QUOTE_LITERAL(REC.RECORD_ID);
    EXECUTE V_SELECT_Q;
    DELETE FROM BDAR_TABLES.DELAYED_DELETE_ROWS DDR WHERE REC.ID = DDR.ID;
    INSERT INTO BDAR_TABLES.CRON_LOG(QUERY, EXECUTED) VALUES (V_SELECT_Q, CURRENT_TIMESTAMP);
END LOOP;
END; $$
$JOB$);


-- DELETE OR DISCONNECT ALL RECORDS RELATED TO ONE SELECTED AND ALSO SELECTED
-- BASIC CONFIGURATION: IF COLUMN NOT NULL - DELETES ELSE IF COLUMN NULLABLE, DISCONECTS ENTITIES
CREATE OR REPLACE FUNCTION BDAR_FORGET(P_SCHEMA VARCHAR, P_TABLE VARCHAR, P_KEY VARCHAR, P_RECURSION VARCHAR[] DEFAULT NULL, FOREIGN_COLUMN VARCHAR DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    RX RECORD;
    RD RECORD;
    V_SQL VARCHAR;
    V_IS_NULLABLE VARCHAR;
    V_RECURSION_KEY VARCHAR;
    RECNUM INTEGER;
    V_PRIMARY_KEY VARCHAR;
    V_ROWS INTEGER;
   	RET_VAL VARCHAR;
    V_INSERT_SQL VARCHAR;
    V_DELETE_AFTER INTEGER;
BEGIN
    RECNUM := 0;
    SELECT CCU.COLUMN_NAME INTO V_PRIMARY_KEY
        FROM
        INFORMATION_SCHEMA.TABLE_CONSTRAINTS  TC
        JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS CCU ON CCU.CONSTRAINT_NAME = TC.CONSTRAINT_NAME AND CCU.CONSTRAINT_SCHEMA=TC.CONSTRAINT_SCHEMA
        AND TC.CONSTRAINT_TYPE='PRIMARY KEY'
        AND TC.TABLE_NAME=P_TABLE
        AND TC.TABLE_SCHEMA=P_SCHEMA;

    FOR RX IN (
        SELECT KCU.TABLE_NAME AS FOREIGN_TABLE_NAME, 
        KCU.COLUMN_NAME AS FOREIGN_COLUMN_NAME, 
        KCU.TABLE_SCHEMA FOREIGN_TABLE_SCHEMA,
        KCU2.COLUMN_NAME AS FOREIGN_TABLE_PRIMARY_KEY
        FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE CCU
        JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC ON TC.CONSTRAINT_NAME=CCU.CONSTRAINT_NAME AND TC.CONSTRAINT_CATALOG=CCU.CONSTRAINT_CATALOG AND CCU.CONSTRAINT_SCHEMA=CCU.CONSTRAINT_SCHEMA 
        JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU ON KCU.CONSTRAINT_NAME=CCU.CONSTRAINT_NAME AND KCU.CONSTRAINT_CATALOG=CCU.CONSTRAINT_CATALOG AND KCU.CONSTRAINT_SCHEMA=CCU.CONSTRAINT_SCHEMA
        JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC2 ON TC2.TABLE_NAME=KCU.TABLE_NAME AND TC2.TABLE_SCHEMA=KCU.TABLE_SCHEMA
        JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU2 ON KCU2.CONSTRAINT_NAME=TC2.CONSTRAINT_NAME AND KCU2.CONSTRAINT_CATALOG=TC2.CONSTRAINT_CATALOG AND KCU2.CONSTRAINT_SCHEMA=TC2.CONSTRAINT_SCHEMA
        WHERE CCU.TABLE_NAME=P_TABLE  AND CCU.TABLE_SCHEMA=P_SCHEMA
        AND TC.CONSTRAINT_TYPE='FOREIGN KEY'
        AND TC2.CONSTRAINT_TYPE='PRIMARY KEY'
	)
    LOOP
        V_SQL := 'SELECT '||RX.FOREIGN_TABLE_PRIMARY_KEY||' AS KEY FROM '||RX.FOREIGN_TABLE_SCHEMA||'.'||RX.FOREIGN_TABLE_NAME||'
            WHERE '||RX.FOREIGN_COLUMN_NAME||'='||QUOTE_LITERAL(P_KEY)||' FOR UPDATE';
        FOR RD IN EXECUTE V_SQL
        LOOP
            V_RECURSION_KEY=RX.FOREIGN_TABLE_SCHEMA||'.'||RX.FOREIGN_TABLE_NAME||'.'||RX.FOREIGN_COLUMN_NAME||'='||RD.KEY;
            IF (V_RECURSION_KEY = ANY (P_RECURSION)) THEN
                RAISE NOTICE 'AVOIDING INFINITE LOOP';
            ELSE
                RECNUM:= RECNUM +BDAR_FORGET(RX.FOREIGN_TABLE_SCHEMA::VARCHAR, RX.FOREIGN_TABLE_NAME::VARCHAR, RD.KEY::VARCHAR, P_RECURSION||V_RECURSION_KEY,  RX.FOREIGN_COLUMN_NAME::VARCHAR);
            END IF;
        END LOOP;
    END LOOP;
    BEGIN
    V_IS_NULLABLE := 'SELECT IS_NULLABLE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '||QUOTE_LITERAL(P_SCHEMA)||' AND TABLE_NAME ='||QUOTE_LITERAL(P_TABLE)||' AND COLUMN_NAME ='||QUOTE_LITERAL(FOREIGN_COLUMN);
   	IF(V_IS_NULLABLE IS NOT NULL) THEN
   		EXECUTE V_IS_NULLABLE INTO RET_VAL;
   	END IF;   
    V_SQL := 'DELETE FROM '||P_SCHEMA||'.'||P_TABLE||' WHERE '||V_PRIMARY_KEY||'='||QUOTE_LITERAL(P_KEY);
   	IF(RET_VAL = 'YES') THEN
   		V_SQL := 'UPDATE '||P_SCHEMA||'.'||P_TABLE||' SET '||FOREIGN_COLUMN||'= NULL WHERE '||V_PRIMARY_KEY||'='||QUOTE_LITERAL(P_KEY);
   		V_DELETE_AFTER:= (SELECT C.VALUE FROM BDAR_TABLES.CONF C WHERE C.PARAM = 'DELETE_WAIT_TIME_MINUTES');
		V_INSERT_SQL:= FORMAT('INSERT INTO BDAR_TABLES.DELAYED_DELETE_ROWS (SCHEMA_NAME, TABLE_NAME, RECORD_ID, DELETE_ON) VALUES(%S,%S,%S,%S)',
   							  QUOTE_LITERAL(P_SCHEMA),QUOTE_LITERAL(P_TABLE),P_KEY, QUOTE_LITERAL(CURRENT_TIMESTAMP + (V_DELETE_AFTER * INTERVAL '1 MINUTE')));
   		EXECUTE V_INSERT_SQL;
    END IF;
    
    EXECUTE V_SQL;
    GET DIAGNOSTICS V_ROWS= ROW_COUNT;
    RECNUM:= RECNUM +V_ROWS;
   
    EXCEPTION WHEN OTHERS THEN RECNUM=0;
    END;

    RETURN RECNUM;
END;
$$
LANGUAGE PLPGSQL;

-- DELETE OR DISCONNECT ALL RECORDS RELATED TO ONE SELECTED AND ALSO SELECTED
-- CONFIGURABLE: ADD ENTITIES TO PRIVATE_ENTITIES TABLE, SO IT DISCONNECTS THAT DATA, OTHER ENTITIES WILL NOT BE PRIVATE AND WILL JUST IMMEDIATELY DELETE
CREATE OR REPLACE FUNCTION BDAR_FORGET_CONFIGURED(P_SCHEMA VARCHAR, P_TABLE VARCHAR, P_KEY VARCHAR, P_RECURSION VARCHAR[] DEFAULT NULL, FOREIGN_COLUMN VARCHAR DEFAULT NULL)
 RETURNS INTEGER AS $$
DECLARE
    RX RECORD;
    RD RECORD;
    V_SQL VARCHAR;
    V_IS_NULLABLE VARCHAR;
    V_RECURSION_KEY VARCHAR;
    RECNUM INTEGER;
    V_PRIMARY_KEY VARCHAR;
    V_ROWS INTEGER;
   	RET_VAL VARCHAR;
    V_INSERT_SQL VARCHAR;
    V_DELETE_AFTER INTEGER;
BEGIN
    RECNUM := 0;
    SELECT CCU.COLUMN_NAME INTO V_PRIMARY_KEY
        FROM
        INFORMATION_SCHEMA.TABLE_CONSTRAINTS  TC
        JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS CCU ON CCU.CONSTRAINT_NAME = TC.CONSTRAINT_NAME AND CCU.CONSTRAINT_SCHEMA=TC.CONSTRAINT_SCHEMA
        AND TC.CONSTRAINT_TYPE='PRIMARY KEY'
        AND TC.TABLE_NAME=P_TABLE
        AND TC.TABLE_SCHEMA=P_SCHEMA;

    FOR RX IN (
        SELECT KCU.TABLE_NAME AS FOREIGN_TABLE_NAME, 
        KCU.COLUMN_NAME AS FOREIGN_COLUMN_NAME, 
        KCU.TABLE_SCHEMA FOREIGN_TABLE_SCHEMA,
        KCU2.COLUMN_NAME AS FOREIGN_TABLE_PRIMARY_KEY
        FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE CCU
        JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC ON TC.CONSTRAINT_NAME=CCU.CONSTRAINT_NAME AND TC.CONSTRAINT_CATALOG=CCU.CONSTRAINT_CATALOG AND CCU.CONSTRAINT_SCHEMA=CCU.CONSTRAINT_SCHEMA 
        JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU ON KCU.CONSTRAINT_NAME=CCU.CONSTRAINT_NAME AND KCU.CONSTRAINT_CATALOG=CCU.CONSTRAINT_CATALOG AND KCU.CONSTRAINT_SCHEMA=CCU.CONSTRAINT_SCHEMA
        JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC2 ON TC2.TABLE_NAME=KCU.TABLE_NAME AND TC2.TABLE_SCHEMA=KCU.TABLE_SCHEMA
        JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU2 ON KCU2.CONSTRAINT_NAME=TC2.CONSTRAINT_NAME AND KCU2.CONSTRAINT_CATALOG=TC2.CONSTRAINT_CATALOG AND KCU2.CONSTRAINT_SCHEMA=TC2.CONSTRAINT_SCHEMA
        WHERE CCU.TABLE_NAME=P_TABLE  AND CCU.TABLE_SCHEMA=P_SCHEMA
        AND TC.CONSTRAINT_TYPE='FOREIGN KEY'
        AND TC2.CONSTRAINT_TYPE='PRIMARY KEY'
	)
    LOOP
        V_SQL := 'SELECT '||RX.FOREIGN_TABLE_PRIMARY_KEY||' AS KEY FROM '||RX.FOREIGN_TABLE_SCHEMA||'.'||RX.FOREIGN_TABLE_NAME||'
            WHERE '||RX.FOREIGN_COLUMN_NAME||'='||QUOTE_LITERAL(P_KEY)||' FOR UPDATE';
        FOR RD IN EXECUTE V_SQL
        LOOP
            V_RECURSION_KEY=RX.FOREIGN_TABLE_SCHEMA||'.'||RX.FOREIGN_TABLE_NAME||'.'||RX.FOREIGN_COLUMN_NAME||'='||RD.KEY;
            IF (V_RECURSION_KEY = ANY (P_RECURSION)) THEN
                RAISE NOTICE 'AVOIDING INFINITE LOOP';
            ELSE
                RECNUM:= RECNUM +BDAR_FORGET_CONFIGURED(RX.FOREIGN_TABLE_SCHEMA::VARCHAR, RX.FOREIGN_TABLE_NAME::VARCHAR, RD.KEY::VARCHAR, P_RECURSION||V_RECURSION_KEY,  RX.FOREIGN_COLUMN_NAME::VARCHAR);
            END IF;
        END LOOP;
    END LOOP;
    BEGIN
    V_SQL := 'DELETE FROM '||P_SCHEMA||'.'||P_TABLE||' WHERE '||V_PRIMARY_KEY||'='||QUOTE_LITERAL(P_KEY);
    SELECT TABLE_NAME FROM BDAR_TABLES.PRIVATE_ENTITIES 
    WHERE BDAR_TABLES.PRIVATE_ENTITIES.TABLE_NAME IN(P_TABLE) 
    AND BDAR_TABLES.PRIVATE_ENTITIES.SCHEMA_NAME IN(P_SCHEMA) INTO RET_VAL;
    V_SQL := 'DELETE FROM '||P_SCHEMA||'.'||P_TABLE||' WHERE '||V_PRIMARY_KEY||'='||QUOTE_LITERAL(P_KEY);
    IF(RET_VAL IS NOT NULL) THEN
   		 V_SQL := 'UPDATE '||P_SCHEMA||'.'||P_TABLE||' SET '||FOREIGN_COLUMN||'= NULL WHERE '||V_PRIMARY_KEY||'='||QUOTE_LITERAL(P_KEY);
		 V_DELETE_AFTER:= (SELECT C.VALUE FROM BDAR_TABLES.CONF C WHERE C.PARAM = 'DELETE_WAIT_TIME_MINUTES');
   		 V_INSERT_SQL:= FORMAT('INSERT INTO BDAR_TABLES.DELAYED_DELETE_ROWS (SCHEMA_NAME, TABLE_NAME, RECORD_ID, DELETE_ON) VALUES(%S,%S,%S,%S)',
   							  QUOTE_LITERAL(P_SCHEMA),QUOTE_LITERAL(P_TABLE),P_KEY, QUOTE_LITERAL(CURRENT_TIMESTAMP + (V_DELETE_AFTER * INTERVAL '1 MINUTE')));   		
   		EXECUTE V_INSERT_SQL;
    END IF;
    EXECUTE V_SQL;
    GET DIAGNOSTICS V_ROWS= ROW_COUNT;
    RECNUM:= RECNUM +V_ROWS;
   
    EXCEPTION WHEN OTHERS THEN RECNUM=0;
    END;

    RETURN RECNUM;
END;
$$
LANGUAGE PLPGSQL;

-- NEEDED FOR LOCALHOST. OTHERWISE DOES NOT WORK

UPDATE CRON.JOB SET NODENAME = '';
